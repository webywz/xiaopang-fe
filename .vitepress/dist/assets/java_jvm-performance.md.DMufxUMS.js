import{_ as a,c as i,o as n,ag as l}from"./chunks/framework.DPDPlp3K.js";const o=JSON.parse('{"title":"Java JVM 与性能调优详解","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm-performance.md","filePath":"java/jvm-performance.md","lastUpdated":1747111449000}'),e={name:"java/jvm-performance.md"};function p(t,s,r,h,k,d){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="java-jvm-与性能调优详解" tabindex="-1">Java JVM 与性能调优详解 <a class="header-anchor" href="#java-jvm-与性能调优详解" aria-label="Permalink to &quot;Java JVM 与性能调优详解&quot;">​</a></h1><h2 id="_1-jvm-体系结构" tabindex="-1">1. JVM 体系结构 <a class="header-anchor" href="#_1-jvm-体系结构" aria-label="Permalink to &quot;1. JVM 体系结构&quot;">​</a></h2><p>JVM（Java Virtual Machine，Java 虚拟机）是 Java 程序运行的核心，主要包括：</p><ul><li><strong>类加载器（ClassLoader）</strong>：负责加载 .class 字节码文件。</li><li><strong>运行时数据区</strong>：包括方法区、堆、虚拟机栈、本地方法栈、程序计数器。</li><li><strong>执行引擎</strong>：解释执行字节码，或通过 JIT 编译成本地代码。</li><li><strong>本地方法接口（JNI）</strong>：调用本地（C/C++）库。</li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>+---------------------+</span></span>
<span class="line"><span>|    类加载器子系统     |</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>|   运行时数据区       |</span></span>
<span class="line"><span>|  ├─ 方法区           |</span></span>
<span class="line"><span>|  ├─ 堆               |</span></span>
<span class="line"><span>|  ├─ 虚拟机栈         |</span></span>
<span class="line"><span>|  ├─ 本地方法栈       |</span></span>
<span class="line"><span>|  └─ 程序计数器       |</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>|   执行引擎           |</span></span>
<span class="line"><span>+---------------------+</span></span>
<span class="line"><span>|   本地方法接口 JNI    |</span></span>
<span class="line"><span>+---------------------+</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><hr><h2 id="_2-垃圾回收-gc-原理与常见算法" tabindex="-1">2. 垃圾回收（GC）原理与常见算法 <a class="header-anchor" href="#_2-垃圾回收-gc-原理与常见算法" aria-label="Permalink to &quot;2. 垃圾回收（GC）原理与常见算法&quot;">​</a></h2><ul><li><strong>GC 目标</strong>：自动回收无用对象，释放内存。</li><li><strong>常见算法</strong>： <ul><li>标记-清除（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-整理（Mark-Compact）</li><li>分代收集（新生代/老年代）</li></ul></li><li><strong>常见收集器</strong>：Serial、ParNew、Parallel、CMS、G1、ZGC、Shenandoah</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手动触发 GC（不推荐，仅用于测试）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><hr><h2 id="_3-jvm-参数与调优" tabindex="-1">3. JVM 参数与调优 <a class="header-anchor" href="#_3-jvm-参数与调优" aria-label="Permalink to &quot;3. JVM 参数与调优&quot;">​</a></h2><h3 id="_3-1-堆与栈内存设置" tabindex="-1">3.1 堆与栈内存设置 <a class="header-anchor" href="#_3-1-堆与栈内存设置" aria-label="Permalink to &quot;3.1 堆与栈内存设置&quot;">​</a></h3><ul><li><code>-Xms</code>：初始堆大小</li><li><code>-Xmx</code>：最大堆大小</li><li><code>-Xss</code>：每个线程的栈大小</li></ul><h3 id="_3-2-gc-日志与分析" tabindex="-1">3.2 GC 日志与分析 <a class="header-anchor" href="#_3-2-gc-日志与分析" aria-label="Permalink to &quot;3.2 GC 日志与分析&quot;">​</a></h3><ul><li><code>-XX:+PrintGCDetails</code>：打印 GC 详细日志</li><li><code>-XX:+PrintGCDateStamps</code>：打印 GC 时间戳</li><li><code>-Xlog:gc*</code>：JDK 9+ 新日志格式</li></ul><h3 id="_3-3-其他常用参数" tabindex="-1">3.3 其他常用参数 <a class="header-anchor" href="#_3-3-其他常用参数" aria-label="Permalink to &quot;3.3 其他常用参数&quot;">​</a></h3><ul><li><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code>：方法区（元空间）大小</li><li><code>-XX:+UseG1GC</code>：使用 G1 收集器</li></ul><hr><h2 id="_4-性能分析与调优工具" tabindex="-1">4. 性能分析与调优工具 <a class="header-anchor" href="#_4-性能分析与调优工具" aria-label="Permalink to &quot;4. 性能分析与调优工具&quot;">​</a></h2><ul><li><strong>jps</strong>：查看 Java 进程</li><li><strong>jstack</strong>：线程堆栈快照，排查死锁</li><li><strong>jmap</strong>：内存映像、堆转储</li><li><strong>jstat</strong>：JVM 运行时统计</li><li><strong>VisualVM</strong>：图形化分析工具</li><li><strong>Java Mission Control (JMC)</strong>：JDK 自带性能分析工具</li></ul><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jps</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                # 查看所有 Java 进程</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jstack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       # 导出线程快照</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jmap</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -heap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 查看堆信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -gc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 每秒输出 GC 信息</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr><h2 id="_5-代码示例与调优实战" tabindex="-1">5. 代码示例与调优实战 <a class="header-anchor" href="#_5-代码示例与调优实战" aria-label="Permalink to &quot;5. 代码示例与调优实战&quot;">​</a></h2><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 模拟内存泄漏示例</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.ArrayList;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.List;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MemoryLeakDemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]&gt; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 持续分配内存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li>运行时可用 <code>-Xmx32m</code> 限制最大堆，观察 OOM（OutOfMemoryError）</li></ul><hr><h2 id="_6-常见易错点" tabindex="-1">6. 常见易错点 <a class="header-anchor" href="#_6-常见易错点" aria-label="Permalink to &quot;6. 常见易错点&quot;">​</a></h2><ul><li>堆/栈设置过小导致 OOM 或 StackOverflowError</li><li>忽视 GC 日志，未及时发现内存泄漏</li><li>频繁 Full GC，应用卡顿</li><li>误用强引用导致对象无法回收</li><li>只关注吞吐量忽略延迟</li></ul><hr><h2 id="_7-进阶拓展" tabindex="-1">7. 进阶拓展 <a class="header-anchor" href="#_7-进阶拓展" aria-label="Permalink to &quot;7. 进阶拓展&quot;">​</a></h2><ul><li>JVM 类加载机制与双亲委派模型</li><li>JIT 编译与逃逸分析</li><li>GC 调优实战（G1、ZGC、CMS 等）</li><li>内存泄漏排查与 MAT 工具</li><li>性能基准测试（JMH）</li></ul><hr><h2 id="_8-参考资料" tabindex="-1">8. 参考资料 <a class="header-anchor" href="#_8-参考资料" aria-label="Permalink to &quot;8. 参考资料&quot;">​</a></h2><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se17/html/index.html" target="_blank" rel="noreferrer">Java 官方 JVM 文档</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html" target="_blank" rel="noreferrer">Java 性能调优官方指南</a></li><li>《深入理解 Java 虚拟机》</li><li>《Java 性能权威指南》</li><li>《Effective Java》</li></ul>`,34)]))}const g=a(e,[["render",p]]);export{o as __pageData,g as default};
