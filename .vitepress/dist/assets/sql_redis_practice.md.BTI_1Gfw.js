import{_ as a,c as i,o as l,ag as t}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"Redis 与 SQL 数据库协同实践","description":"","frontmatter":{},"headers":[],"relativePath":"sql/redis/practice.md","filePath":"sql/redis/practice.md","lastUpdated":1747222037000}'),r={name:"sql/redis/practice.md"};function s(d,e,o,c,n,h){return l(),i("div",null,e[0]||(e[0]=[t('<h1 id="redis-与-sql-数据库协同实践" tabindex="-1">Redis 与 SQL 数据库协同实践 <a class="header-anchor" href="#redis-与-sql-数据库协同实践" aria-label="Permalink to &quot;Redis 与 SQL 数据库协同实践&quot;">​</a></h1><h2 id="协同模式" tabindex="-1">协同模式 <a class="header-anchor" href="#协同模式" aria-label="Permalink to &quot;协同模式&quot;">​</a></h2><ul><li>读多写少的数据可先查 Redis，未命中再查 SQL 数据库并回写缓存（Cache Aside Pattern）。</li><li>重要数据写入时需保证 Redis 与数据库一致性，可采用延迟双删、消息队列等方案。</li><li>Redis 适合存储临时性、非强一致性数据，核心业务数据仍建议落地 SQL 数据库。</li></ul><h2 id="缓存常见模式" tabindex="-1">缓存常见模式 <a class="header-anchor" href="#缓存常见模式" aria-label="Permalink to &quot;缓存常见模式&quot;">​</a></h2><ul><li>Cache Aside（旁路缓存）：应用先查缓存，未命中再查数据库并写入缓存。</li><li>Read/Write Through：所有读写都通过缓存层，缓存自动同步数据库。</li><li>Write Back（回写）：写操作先写缓存，异步批量写入数据库。</li></ul><h2 id="数据一致性建议" tabindex="-1">数据一致性建议 <a class="header-anchor" href="#数据一致性建议" aria-label="Permalink to &quot;数据一致性建议&quot;">​</a></h2><ul><li>关键业务数据建议采用延迟双删（写库前后各删除一次缓存）。</li><li>利用消息队列异步同步缓存与数据库，提升一致性。</li><li>对于高一致性要求的场景，建议只用数据库，缓存仅作加速。</li></ul><hr><p>合理利用 Redis 与 SQL 数据库的优势，可显著提升系统性能与可扩展性。</p>',9)]))}const p=a(r,[["render",s]]);export{u as __pageData,p as default};
