# Oracle 实战案例：高并发事务处理

## 1. 需求描述
以"账户转账"为例，要求在高并发下保证资金安全、数据一致性，防止超发、脏读、死锁等问题，适合金融、电商、库存等场景。

## 2. 表结构设计
```sql
CREATE TABLE accounts (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  balance NUMBER(18,2) NOT NULL DEFAULT 0,
  updated_at DATE DEFAULT SYSDATE,
  UNIQUE(user_id)
);

CREATE TABLE transfer_log (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_id NUMBER,
  to_id NUMBER,
  amount NUMBER(18,2),
  status VARCHAR2(16) DEFAULT 'success',
  created_at DATE DEFAULT SYSDATE
);
```

## 3. 核心 SQL 示例
```sql
-- 转账事务伪代码
BEGIN
  SELECT balance INTO :bal FROM accounts WHERE id = :from_id FOR UPDATE;
  IF :bal < :amount THEN RAISE_APPLICATION_ERROR(-20001, '余额不足'); END IF;
  UPDATE accounts SET balance = balance - :amount WHERE id = :from_id;
  UPDATE accounts SET balance = balance + :amount WHERE id = :to_id;
  INSERT INTO transfer_log (from_id, to_id, amount, status) VALUES (:from_id, :to_id, :amount, 'success');
COMMIT;

-- 查询账户余额
SELECT balance FROM accounts WHERE id = :id FOR UPDATE;
```

## 4. Node.js 代码示例（含 JSDoc 注释）
```js
/**
 * 账户转账（高并发事务安全）
 * @param {oracledb.Connection} conn
 * @param {number} fromId
 * @param {number} toId
 * @param {number} amount
 * @returns {Promise<boolean>} 是否成功
 */
async function transfer(conn, fromId, toId, amount) {
  try {
    await conn.execute('BEGIN');
    const { rows } = await conn.execute('SELECT balance FROM accounts WHERE id = :id FOR UPDATE', { id: fromId });
    if (!rows[0] || rows[0].BALANCE < amount) throw new Error('余额不足');
    await conn.execute('UPDATE accounts SET balance = balance - :amount WHERE id = :id', { amount, id: fromId });
    await conn.execute('UPDATE accounts SET balance = balance + :amount WHERE id = :id', { amount, id: toId });
    await conn.execute('INSERT INTO transfer_log (from_id, to_id, amount, status) VALUES (:fromId, :toId, :amount, :status)', { fromId, toId, amount, status: 'success' });
    await conn.execute('COMMIT');
    return true;
  } catch (e) {
    await conn.execute('ROLLBACK');
    await conn.execute('INSERT INTO transfer_log (from_id, to_id, amount, status) VALUES (:fromId, :toId, :amount, :status)', { fromId, toId, amount, status: 'fail' });
    return false;
  }
}
```

## 5. 优化与总结
- 关键更新用 FOR UPDATE 加行锁，防止并发超发
- 事务内操作精简，避免长事务
- 记录流水便于审计与追溯
- 建议捕获死锁异常并重试
- 余额字段用 NUMBER，防止精度丢失
- 定期归档 transfer_log，防止表膨胀

---

本案例适合金融、电商、库存等高并发资金/库存场景，建议结合业务实际完善风控与异常处理。 