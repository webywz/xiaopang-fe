# Oracle 实战案例：分区表与大数据量

## 1. 需求描述
以"订单历史归档"为例，要求在订单量极大时，提升查询与维护效率，支持按月分区、快速归档与清理历史数据，适合金融、电商、日志等大数据量场景。

## 2. 表结构设计
```sql
-- 创建主分区表（按月范围分区）
CREATE TABLE orders (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id NUMBER NOT NULL,
  order_no VARCHAR2(32) NOT NULL,
  amount NUMBER(12,2) NOT NULL,
  status VARCHAR2(16) NOT NULL,
  created_at DATE NOT NULL,
  UNIQUE(order_no)
)
PARTITION BY RANGE (created_at) (
  PARTITION p202401 VALUES LESS THAN (TO_DATE('2024-02-01','YYYY-MM-DD')),
  PARTITION p202402 VALUES LESS THAN (TO_DATE('2024-03-01','YYYY-MM-DD'))
  -- 可按需自动化创建更多分区
);
```

## 3. 核心 SQL 示例
```sql
-- 插入数据自动路由到分区
INSERT INTO orders (user_id, order_no, amount, status, created_at)
VALUES (1, 'ORD20240101001', 100.00, 'paid', TO_DATE('2024-01-01 10:00:00','YYYY-MM-DD HH24:MI:SS'));

-- 查询指定月份订单
SELECT * FROM orders PARTITION (p202401);

-- 归档/清理历史分区
ALTER TABLE orders DROP PARTITION p202312;

-- 查看分区表结构
SELECT table_name, partition_name, high_value FROM user_tab_partitions WHERE table_name = 'ORDERS';
```

## 4. Node.js 代码示例（含 JSDoc 注释）
```js
/**
 * 查询指定月份订单（分区表自动优化）
 * @param {oracledb.Connection} conn
 * @param {string} partitionName - 分区名，如 'P202401'
 * @returns {Promise<Array>}
 */
async function getOrdersByPartition(conn, partitionName) {
  const sql = `SELECT * FROM orders PARTITION (${partitionName})`;
  const result = await conn.execute(sql);
  return result.rows;
}

/**
 * 自动归档历史分区（删除指定分区）
 * @param {oracledb.Connection} conn
 * @param {string} partitionName - 分区名，如 'P202312'
 * @returns {Promise<void>}
 */
async function dropOrderPartition(conn, partitionName) {
  await conn.execute(`ALTER TABLE orders DROP PARTITION ${partitionName}`);
}
```

## 5. 优化与总结
- 合理选择分区键（如时间、ID范围），避免数据倾斜
- 定期创建新分区、归档旧分区，提升维护效率
- 分区表可单独建索引，提升分区内查询性能
- 查询时带分区键条件，充分利用分区裁剪
- 注意分区数量过多可能影响元数据管理
- 可结合自动化脚本定期维护分区

---

本案例适合金融、电商、日志等大数据量场景，建议结合业务需求灵活调整分区策略。 